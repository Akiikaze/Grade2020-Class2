
# 简易实现单调队列优化
---
[[背包问题/优化三☞单调队列优化|优化三☞单调队列优化]]

好吧，有很简单的方法实现它，也很方便我们理解。

- 假设存在一个数组`a[N]`,这个数组已经存入了数字
- 设计`q[M]`数组存储下标。
> 这里的 q 数组即为我们存储的单调队列块，这个块存储的地址指向`a[]`中的各个值，队首符合要求
- 假设规则为输出最小的数，且在连续的、长为k（这里就设为3吧）的块上寻找
- h-＞heading，队首坐标
- t-＞tail ，队尾坐标

# 原理
---
**这里以 i 作为窗口尾部的位置，窗口从此向前滑动**
- **队尾出队条件：** 队列不空且新元素更优  `在实例中是队尾的数不是最大的`  那么就将其弹出
>实现方式：t-- -->t 前移，则队尾的坐标变为`t-1`,所以这个`q[t]`存储的地址就指向`a[t]`（操作前）的前一个数，相当于把它弹出了。
- **队首出队条件：** 超出窗口长度 即`q[h]<i-k+1`时，将队首弹出
>实现方式：h++ --> h后移，指向后一个数

# 优化代码实现
---
假设弹出$[i-k,i]$上的最小值

```cpp
//对于数组a[n]
int k,q[n],h=1,t=0; //窗口长度, q[n], heading, tail
for(int i=1; i<=n; i++){
	while(h <= t && a[i] <= a[q[t]]) t--;
	t++;
	q[t] = i; //录入值
	if( q[h] < i-k+1 ) h++;//弹出队首
	if(i >= k)//长度够了，已经有窗口了
		printf("%d",a[q[h]]);-->这里就是队首的结果
}
```

- **图例如下**
图片以Base64保存，所以我把代码放在上面了

![image.png](https://github.com/Da1dr1em/Grade2020-Class2/blob/main/Somnus(NGL)/%E4%B9%B1%E5%AD%A6/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/%E9%99%84%E5%9B%BE%E4%BF%9D%E5%AD%98/double-ended-queue-sample.png)
