# 二维

-  以```f[i][j]```代表第i个物品、背包容积j的情形下最大的价值
-  先定义一下：
```cpp
define N num
int v[N],w[N]; //第i个物品的 v-->体积 w-->价值
int f[N][N];
int V,L; //V-->背包容积 L-->物品种类

int main(){
...
}

```
# 对于01背包问题

[[AcWing 2 01背包问题（状态转移方程讲解）]]

```cpp
int main(){
	cin>>L>>V;
	for(int i=1;i<=L;i++){
		cin>>v[i]>>w[i];
	}
	for(int i=1;i<=L;i++){
		for(int j=1;j<=V;j++){
			if(j>=v[i]){
				f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]);
				//要么不放（等于f[i-1][j]）要么放一个
			}else{
				f[i][j]=f[i-1][j];   //不放
			}
		}
	}
```

## 如何将二维优化为一维？

- 在上面的代码中，实际上i并没有太大的作用（f中）。因此可否用一维表示？
- 若仅仅使用```f[j]```那么存在一个问题：循环第i个物品时，若j从0开始循环，当```j>v[i]```时执行的```f[j-v[i]]```已经被本轮循环污染。那就只能从后向前循环。代码如下：
```cpp
    for(int i=1;i<=N;i++){
        for(int j=V;j>=v[i];j--){
            si[j]=max(si[j],si[j-v[i]]+w[i]);
        }
    }
```
当然，这里的if语句被简化到了for的条件中。
 *显然我们可以把它应用到其他背包的问题中*
# 完全背包问题

[[3 完全背包问题 - AcWing题库]]

- 完全背包不一样
- 01背包要求每个物品选或不选，因此遍历时不能从前往后会被第i个污染
- 但是完全背包就是要选多次，所以就是要从前往后让它迭代

```cpp
    for(int i=1;i<=N;i++){
        for(int j=v[i];j<=V;j++){
            si[j]=max(si[j],si[j-v[i]]+w[i]);
        }
    }
```


# 多重背包

[[AcWing 4 多包 I(一看就会,懒人专用)+精简代码 -]]